math.randomseed(os.time())

ENEMY_WIDTH, ENEMY_HEIGHT = 27, 25
ENEMY_HEALTH = 100
ENEMY_ATTACK_COOLDOWN = 4

ENEMY_MOVEMENTS = { RANDOM = 1, CHASING = 2 }

local function getRandomPos()
	return { x = math.random(ENEMY_WIDTH / 2, WINDOW_WIDTH - ENEMY_WIDTH / 2), y = math.random(ENEMY_HEIGHT / 2, WINDOW_HEIGHT - ENEMY_HEIGHT / 2) }
end


local MOVE_DURATION = 2
local function moveRandomly(self)
	self.movingToPos = getRandomPos()
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, self.movingToPos.x, go.EASING_LINEAR, MOVE_DURATION, 0, function(self)
		moveRandomly(self)
	end)
	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, self.movingToPos.y, go.EASING_LINEAR, MOVE_DURATION, 0)
end

go.property("hasCrate", false)
go.property("hasGem", false)
go.property("crateItemId", 0)
function init(self)
	self.health = ENEMY_HEALTH
	self.movingToPos = nil
	self.hasCrate = false
	
	moveRandomly(self)

	self.pos = go.get_position()
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	self.pos = go.get_position()
end

function on_message(self, message_id, message, sender)
	if (message_id == hash("trigger_response")) then
		if (message.group == hash("bullets")) then
			local damage = go.get(msg.url("main", message.other_id, "Bullet"), "damage")
			self.health = math.max(0, self.health - damage)
			if (self.health == 0) then
				if (self.hasCrate) then msg.post("/Crate factory", MESSAGE_IDS.SPAWN_CRATE, {spawn_position = go.get_position(), item_id = self.crateItemId}) end
				if (self.hasGem) then
					msg.post("/Gem factory", MESSAGE_IDS.SPAWN_GEM, { spawn_position = go.get_position() })
				end
				go.delete()
				ENEMY_COUNT = ENEMY_COUNT - 1
			end
		end
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end