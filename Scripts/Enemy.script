math.randomseed(os.time())

ENEMY_WIDTH, ENEMY_HEIGHT = 27, 25
ENEMY_HEALTH = 100
ENEMY_ATTACK_COOLDOWN = 4

local moveRandomly
local chasePlayer

local function getRandomPos()
	return { x = math.random(ENEMY_WIDTH / 2, WINDOW_WIDTH - ENEMY_WIDTH / 2), y = math.random(ENEMY_HEIGHT / 2, WINDOW_HEIGHT - ENEMY_HEIGHT / 2) }
end

local MOVE_DURATION = 2
moveRandomly = function(self)
	self.movingToPos = getRandomPos()
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, self.movingToPos.x, go.EASING_LINEAR, MOVE_DURATION, 0, function(self)
		moveRandomly(self)
	end)
	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, self.movingToPos.y, go.EASING_LINEAR, MOVE_DURATION, 0)
end

local CHASING_DURATION = 3
chasePlayer = function(self)
	self.chaseFinished = false
	local playerPos = go.get("/Player", "position")
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, playerPos.x, go.EASING_LINEAR, CHASING_DURATION, 0, function(self)
		self.chaseFinished = true
	end)
	go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, playerPos.y, go.EASING_LINEAR, CHASING_DURATION)
end

local function flickersWhenDamaged(self)
	local id = go.get_id()
	self.invulnerableTimer = Timer.every(0.1, function(self)
		if (self.isEnabled) then
			msg.post(id, "disable")
			self.isEnabled = false
		else
			msg.post(id, "enable")
			self.isEnabled = true
		end
	end):finish(function() 
		self.invulnerable = false 
	end)
	self.invulnerableTimer:limit(5)
end

go.property("hasCrate", false)
go.property("hasGem", false)
go.property("crateItemId", 0)
go.property("invulnerable", false)
go.property("isEnabled", true)
go.property("onlyChase", false)
go.property("onlyMoveRandom", false)
go.property("chaseFinished", true)

function init(self)
	self.health = ENEMY_HEALTH
	self.movingToPos = nil

	self.pos = go.get_position()

	if (self.onlyMoveRandom) then
		moveRandomly(self)
	elseif (self.onlyChase) then
		self.chaseFinished = true
	end
end

function final(self)
	self.invulnerableTimer:remove()
end

function update(self, dt)
	self.pos = go.get_position()

	if (self.onlyChase and go.get("/Player#Player", "invulnerable") == false) then
		if (self.chaseFinished) then
			chasePlayer(self)
		end
	end
end

function on_message(self, message_id, message, sender)
	if (message_id == hash("trigger_response")) then
		if (message.group == hash("bullets")) then
			local damage = go.get(msg.url("main", message.other_id, "Bullet"), "damage")
			self.health = math.max(0, self.health - damage)

			if (not self.invulnerable) then
				self.invulnerable = true
				flickersWhenDamaged(self)
			end

			if (self.health == 0) then
				if (self.hasCrate) then msg.post("/Crate factory", MESSAGE_IDS.SPAWN_CRATE, {spawn_position = go.get_position(), item_id = self.crateItemId}) end
				if (self.hasGem) then
					msg.post("/Gem factory", MESSAGE_IDS.SPAWN_GEM, { spawn_position = go.get_position() })
				end
				go.delete()
				self.invulnerableTimer:remove()
				
				msg.post("/Enemy collection factories#Level controller", MESSAGE_IDS.ON_AN_ENEMY_DEATH, { dead_id = go.get_id() })
			end
		end
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end